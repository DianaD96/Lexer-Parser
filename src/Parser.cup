import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  private boolean debug = false;
  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:};
 
// Do something with ILLEGAL_CHARARCTER or drop it.
terminal INT, FLOAT, RAT, CHAR, STR, TDEF, IDENTIFIER, COMMENT, BOOLEAN, LET, EQUAL, SEMICOL, PLUS, MINUS, MULT, DIV;
terminal LEN, INDEX;
terminal READ, PRINT, IF, THEN, FI, ELSE, ELIF, WHILE, DO, OD, FORALL, IN, RETURN;
terminal ALIAS, DICT, SEQ, DICTD, SEQD, DATATYPE, PRPAREN, PLPAREN;
terminal SLPAREN, SRPAREN, LPAREN, RPAREN, CRPAREN, CLPAREN, COLON, COMMA, DOT, DOTDOT;
terminal BADCHAR; 

nonterminal statements, statement, top_level;
nonterminal types,let_bind, full_exp, simple_exp, operator, colon, dictionary_value, dictionary, sequence, dictionary_assignment, sequence_operations;
nonterminal alias, declaration_list, data_type_declaration, method_declarations, method_input, method_input2;

precedence left EQUAL;
precedence left PLUS, MINUS;
precedence left DIV, MULT;


top_level ::= statements:ss {:
                if(debug()) System.out.println((Node)ss);
              :}
            ;

statements ::= statements:ss statement:s {:
                  Node n = (Node)ss;
                  n.addChild((Node)s);
                  RESULT = n;
               :}
             | /* empty */ {:
                  RESULT = new Node("Statements");
               :}
             ;

statement ::= let_bind:s {::}
            | full_exp:s {::}
            | simple_exp:s {::}
            | alias:s {::}
            | sequence:s {::}
            | dictionary:s {::}
            | dictionary_assignment:s {::}
            | sequence_operations:s {::}
            | data_type_declaration:s {::}
            | method_declarations {::};
      
//Change Identifier t to expression
z_statements ::= IDENTIFIER:i EQUAL IDENTIFIER:t SEMICOL {:
				:}
				|
				DATATYPE:s IDENTIFIER:i EQUAL IDENTIFIER:t SEMICOL {:
				:}
				| READ IDENTIFIER:i SEMICOL {:
				:}
				| PRINT IDENTIFIER:t SEMICOL {:
				:}
				| dictionary SEMICOL{:
				:};
				
types ::=  INT:i       {: RESULT = new Node(i); :}
        | RAT:i        {: RESULT = new Node(i); :}
        | FLOAT:i      {: RESULT = new Node(i); :}
        | BOOLEAN:i    {: RESULT = new Node(i); :}
        | CHAR:i       {: RESULT = new Node(i); :}
        | STR:i        {: RESULT = new Node(i); :}
        | COMMENT:t    {: RESULT = new Node(t); :};
             
full_exp ::= simple_exp:e SEMICOL {::};
         
simple_exp ::= types:i {::}
            | IDENTIFIER:i {::}
            | simple_exp:e1 operator:o simple_exp:e2 {::}
            | simple_exp:e1 EQUAL simple_exp:e2 {::};
            
operator ::= PLUS  {: RESULT = new Node("+"); :}
           | MINUS {: RESULT = new Node("-"); :}
           | MULT  {: RESULT = new Node("*"); :}
           | DIV   {: RESULT = new Node("/"); :};
           
sequence ::= SEQD PLPAREN DATATYPE:i PRPAREN IDENTIFIER:t EQUAL SEQ:k {::}
           | SEQD PLPAREN DATATYPE:i PRPAREN IDENTIFIER:t EQUAL STR:k {::}
           | SEQD PLPAREN IDENTIFIER:t PRPAREN {::};

dictionary ::= DICTD PLPAREN DATATYPE:i COMMA DATATYPE:j PRPAREN IDENTIFIER:t EQUAL DICT:k {::};
             
dictionary_assignment ::= IDENTIFIER:t SLPAREN IDENTIFIER:i SRPAREN EQUAL IDENTIFIER:j {::};

sequence_operations ::= LEN LPAREN IDENTIFIER:t RPAREN {::}
                      | LEN LPAREN IDENTIFIER:t RPAREN operator:e INT:i {::}
                      | IDENTIFIER:t INDEX:s {::}
                      | IDENTIFIER:t SLPAREN LEN LPAREN IDENTIFIER:s RPAREN INT:i SRPAREN {::}
                      | IDENTIFIER:t SLPAREN LEN LPAREN IDENTIFIER:s RPAREN operator:e INT:i SRPAREN {::}
                      | IDENTIFIER:t SLPAREN IDENTIFIER:s operator:e INT:i SRPAREN {::}
                      | IDENTIFIER:t SLPAREN INT:i COLON INT:j SRPAREN {::}
                      | IDENTIFIER:t SLPAREN COLON INT:J SRPAREN {::}
                      | IDENTIFIER:t SLPAREN INT:i COLON SRPAREN {::}
                      | IDENTIFIER:t SLPAREN INT:i COLON sequence_operations:e {::};
                      
                      
colon ::= COLON {::};

declaration_list ::= IDENTIFIER:i IDENTIFIER:j {::}
                   | IDENTIFIER:i IDENTIFIER:j COMMA declaration_list:e {::}
                   | DATATYPE:i IDENTIFIER:j {::}
                   | DATATYPE:i IDENTIFIER:j COMMA declaration_list:e {::}
                   | sequence:e IDENTIFIER:j {::}
                   | sequence:f IDENTIFIER:g COMMA declaration_list:h {::};
                    
data_type_declaration ::= TDEF IDENTIFIER:i CLPAREN declaration_list:e CRPAREN SEMICOL {::};


// Doesn't solve double> nested functions
method_input ::= types:i {::}
               | types:i COMMA method_input:j {::}
               | types:i COMMA IDENTIFIER {::}
               | IDENTIFIER COMMA types {::}
               | IDENTIFIER:i LPAREN method_input:j RPAREN {::}
               | IDENTIFIER:i LPAREN RPAREN {::}
               | IDENTIFIER:i LPAREN method_input:j RPAREN COMMA types {::}
               | IDENTIFIER:i LPAREN RPAREN COMMA types {::};

 
method_declarations ::= IDENTIFIER:i DOT IDENTIFIER:j {::}
                      | IDENTIFIER:i DOTDOT method_declarations {::}
                      | IDENTIFIER:i DOTDOT SEQ {::}
                      | IDENTIFIER:i LPAREN RPAREN {::}
                      | IDENTIFIER:i LPAREN method_input RPAREN {::} 
                      | method_declarations:i operator:e INT:j{::}
                      | method_declarations:i operator:e FLOAT:j{::}
                      | method_declarations:i operator:e RAT:j{::}
                      | INT:j operator:e method_declarations:i {::}
                      | FLOAT:j operator:e method_declarations:i {::}
                      | RAT:j operator:e method_declarations:i {::};
                      
alias ::= ALIAS DATATYPE IDENTIFIER {::}
        | ALIAS SEQD PLPAREN DATATYPE PRPAREN IDENTIFIER {::}
        | ALIAS DICTD PLPAREN DATATYPE:i COMMA DATATYPE:j PRPAREN IDENTIFIER {::};
