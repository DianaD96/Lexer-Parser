import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  private boolean debug = false;
  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

  public void syntax_error(Symbol current_token) {
		report_error(
			"Syntax error at line " + (current_token.left+1) + ", column " + current_token.right, null
			); 
  }
	
:};
 
// Do something with ILLEGAL_CHARARCTER or drop it.
terminal INT, FLOAT, RAT, CHAR, STR, TDEF, IDENTIFIER, COMMENT, BOOLEAN, LET, EQUAL, SEMICOL, PLUS, MINUS, MULT, DIV;
terminal LEN, INDEX;
terminal READ, PRINT, IF, THEN, FI, ELSE, ELIF, WHILE, DO, OD, FORALL, IN, RETURN, VOID;
terminal ALIAS, DICT, SEQ, DICTD, SEQD, DATATYPE, PRPAREN, PLPAREN;
terminal SLPAREN, SRPAREN, LPAREN, RPAREN, CRPAREN, CLPAREN, COLON, COMMA, DOT, DOTDOT;
terminal BADCHAR; 

nonterminal statements, statement, top_level;
nonterminal if_statement, do_statement, while_statement, for_all_statement, expression;
nonterminal methods, types,let_bind, full_exp, simple_exp, operator, colon, dictionary_value, dictionary, sequence, dictionary_assignment, sequence_operations;
nonterminal alias, declaration_list, data_type_declaration, method_declarations, method_input, z_statements, after_then;

precedence left EQUAL;
precedence left PLUS, MINUS;
precedence left DIV, MULT;


top_level ::= statements:ss {:
                if(debug()) System.out.println((Node)ss);
              :}
            ;

statements ::= statements:ss statement:s {:
                  Node n = (Node)ss;
                  n.addChild((Node)s);
                  RESULT = n;
               :}
             | /* empty */ {:
                  RESULT = new Node("Statements");
               :}
             ;

statement ::= let_bind:s {::}
            | full_exp:s {::}
            | simple_exp:s {::}
            | alias:s {::}
            | sequence:s {::}
            | dictionary:s {::}
            | z_statements {::}
            | expression {::}
            | dictionary_assignment:s {::}
            | sequence_operations:s {::}
            | data_type_declaration:s {::}
            | method_declarations {::}
            | methods {::};
      
				
types ::=  INT:i       {: RESULT = new Node(i); :}
        | RAT:i        {: RESULT = new Node(i); :}
        | FLOAT:i      {: RESULT = new Node(i); :}
        | BOOLEAN:i    {: RESULT = new Node(i); :}
        | CHAR:i       {: RESULT = new Node(i); :}
        | STR:i        {: RESULT = new Node(i); :}
        | COMMENT:t    {: RESULT = new Node(t); :};
             
full_exp ::= simple_exp:e SEMICOL {::}
           | sequence SEMICOL {::}
           | sequence_operations SEMICOL {::}
           | dictionary_assignment SEMICOL {::}
           | method_declarations SEMICOL{::}
           | data_type_declaration SEMICOL {::};  
                  
simple_exp ::= types:i {::}
            | IDENTIFIER:i {::}
            | simple_exp:e1 operator:o simple_exp:e2 {::}
            | simple_exp:e1 EQUAL simple_exp:e2 {::};
            
operator ::= PLUS  {: RESULT = new Node("+"); :}
           | MINUS {: RESULT = new Node("-"); :}
           | MULT  {: RESULT = new Node("*"); :}
           | DIV   {: RESULT = new Node("/"); :};
           
sequence ::= SEQD PLPAREN DATATYPE:i PRPAREN IDENTIFIER:t EQUAL SEQ:k {::}
           | SEQD PLPAREN DATATYPE:i PRPAREN IDENTIFIER:t EQUAL STR:k {::}
           | SEQD PLPAREN IDENTIFIER:t PRPAREN {::};

dictionary ::= DICTD PLPAREN DATATYPE:i COMMA DATATYPE:j PRPAREN IDENTIFIER:t EQUAL DICT:k {::};
             
dictionary_assignment ::= IDENTIFIER:t SLPAREN IDENTIFIER:i SRPAREN EQUAL IDENTIFIER:j {::};

sequence_operations ::= LEN LPAREN IDENTIFIER:t RPAREN {::}
                      | LEN LPAREN IDENTIFIER:t RPAREN operator:e INT:i {::}
                      | IDENTIFIER:t INDEX:s {::}
                      | IDENTIFIER:t SLPAREN LEN LPAREN IDENTIFIER:s RPAREN INT:i SRPAREN {::}
                      | IDENTIFIER:t SLPAREN LEN LPAREN IDENTIFIER:s RPAREN operator:e INT:i SRPAREN {::}
                      | IDENTIFIER:t SLPAREN IDENTIFIER:s operator:e INT:i SRPAREN {::}
                      | IDENTIFIER:t SLPAREN INT:i COLON INT:j SRPAREN {::}
                      | IDENTIFIER:t SLPAREN COLON INT:J SRPAREN {::}
                      | IDENTIFIER:t SLPAREN INT:i COLON SRPAREN {::}
                      | IDENTIFIER:t SLPAREN INT:i COLON sequence_operations:e {::};
                      
                      
colon ::= COLON {::};

declaration_list ::= IDENTIFIER:i IDENTIFIER:j {::}
                   | IDENTIFIER:i IDENTIFIER:j COMMA declaration_list:e {::}
                   | DATATYPE:i IDENTIFIER:j {::}
                   | DATATYPE:i IDENTIFIER:j COMMA declaration_list:e {::}
                   | sequence:e IDENTIFIER:j {::}
                   | sequence:f IDENTIFIER:g COMMA declaration_list:h {::};
                    
data_type_declaration ::= TDEF IDENTIFIER:i CLPAREN declaration_list:e CRPAREN {::};


// Doesn't solve double> nested functions
method_input ::= types:i {::}
               | types:i COMMA method_input:j {::}
               | types:i COMMA IDENTIFIER {::}
               | IDENTIFIER COMMA types {::}
               | IDENTIFIER:i LPAREN method_input:j RPAREN {::}
               | IDENTIFIER:i LPAREN RPAREN {::}
               | IDENTIFIER:i LPAREN method_input:j RPAREN COMMA types {::}
               | IDENTIFIER:i LPAREN RPAREN COMMA types {::};

 
method_declarations ::= IDENTIFIER:i DOT IDENTIFIER:j {::}
                      | IDENTIFIER:i DOTDOT method_declarations {::}
                      | IDENTIFIER:i DOTDOT SEQ {::}
                      | IDENTIFIER:i LPAREN RPAREN {::}
                      | IDENTIFIER:i LPAREN IDENTIFIER RPAREN {::} 
                      | IDENTIFIER:i LPAREN method_input RPAREN {::} 
                      | method_declarations:i operator:e INT:j{::}
                      | method_declarations:i operator:e FLOAT:j{::}
                      | method_declarations:i operator:e RAT:j{::}
                      | INT:j operator:e method_declarations:i {::}
                      | FLOAT:j operator:e method_declarations:i {::}
                      | RAT:j operator:e method_declarations:i {::};
                      
methods ::= IDENTIFIER CLPAREN statements CRPAREN SEMICOL {::};
                 
alias ::= ALIAS DATATYPE IDENTIFIER {::}
        | ALIAS SEQD PLPAREN DATATYPE PRPAREN IDENTIFIER {::}
        | ALIAS DICTD PLPAREN DATATYPE:i COMMA DATATYPE:j PRPAREN IDENTIFIER {::};


//1.REPLACE IDENTIFIER WITH FUNCTION BODY
after_then ::= full_exp {::}
             | full_exp FI {::}
             | full_exp ELSE after_then {::}
             | do_statement FI {::}
             | while_statement FI {::}
             | for_all_statement FI {::};
             
if_statement ::= IF LPAREN simple_exp RPAREN THEN after_then {::}
			  | ELIF LPAREN IDENTIFIER RPAREN THEN after_then {::};
			  
do_statement ::= DO expression OD {::}
               | DO if_statement OD {::}
               | DO do_statement OD {::}
               | DO while_statement OD {::}
               | DO for_all_statement OD {::};
               
while_statement ::= WHILE LPAREN expression RPAREN do_statement {::};

for_all_statement ::= FORALL LPAREN INT IN SEQ RPAREN do_statement {::}
                    | FORALL LPAREN FLOAT IN SEQ RPAREN do_statement {::}
                    | FORALL LPAREN RAT IN SEQ RPAREN do_statement {::}
                    | FORALL LPAREN CHAR IN SEQ RPAREN do_statement {::}
                    | FORALL LPAREN STR IN SEQ RPAREN do_statement {::}
                    | FORALL LPAREN INT IN DICT RPAREN do_statement {::}
                    | FORALL LPAREN FLOAT IN DICT RPAREN do_statement {::}
                    | FORALL LPAREN RAT IN DICT RPAREN do_statement {::}
                    | FORALL LPAREN CHAR IN DICT RPAREN do_statement {::}
                    | FORALL LPAREN STR IN DICT RPAREN do_statement {::};

//Change Identifier t to expression 
// 1. REPLACE IDENTIFIER WITH FUNCTION BODY
z_statements ::= dictionary SEMICOL{::}
				| if_statement {::}
				| do_statement {::}
				| while_statement {::}
				| for_all_statement {::}
				| RETURN IDENTIFIER SEMICOL {::};
				
expression ::= DATATYPE:s IDENTIFIER:i EQUAL IDENTIFIER:t SEMICOL {::}
                | DATATYPE:s IDENTIFIER:i EQUAL IDENTIFIER:t INT SEMICOL {::}
                | DATATYPE:s IDENTIFIER:i SEMICOL {::}
				| READ IDENTIFIER:i SEMICOL {::} //input
				| PRINT simple_exp SEMICOL {::}; //output
				

