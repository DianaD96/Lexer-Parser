import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  private boolean debug = false;
  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:};
 
// Do something with ILLEGAL_CHARARCTER or drop it.
terminal INT, FLOAT, RAT, CHAR, STR, TDEF, IDENTIFIER, COMMENT, BOOLEAN, LET, EQUAL, SEMICOL, PLUS, MINUS, MULT, DIV;
terminal LEN, INDEX;
terminal DICT, SEQ, DICTD, SEQD, DATATYPE, PRPAREN, PLPAREN;
terminal SLPAREN, SRPAREN, LPAREN, RPAREN, CRPAREN, CLPAREN, COLON, COMMA, DOT;
terminal BADCHAR; 

nonterminal statements, statement, top_level;
nonterminal types, let_bind, full_exp, simple_exp, operator, colon, dictionary_value, dictionary, sequence, dictionary_assignment, sequence_operations;
nonterminal declaration_list, data_type_declaration, method_declarations;

precedence left EQUAL;
precedence left PLUS, MINUS;
precedence left DIV, MULT;


top_level ::= statements:ss {:
                if(debug()) System.out.println((Node)ss);
              :}
            ;

statements ::= statements:ss statement:s {:
                  Node n = (Node)ss;
                  n.addChild((Node)s);
                  RESULT = n;
               :}
             | /* empty */ {:
                  RESULT = new Node("Statements");
               :}
             ;

statement ::= let_bind:s {::}
            | full_exp:s {::}
            | simple_exp:s {::}
            | sequence:s {::}
            | dictionary_assignment:s {::}
            | sequence_operations:s {::}
            | data_type_declaration:s {::}
            | method_declarations {::};
      
types ::=  INT:i            {: RESULT = new Node(i); :}
             | RAT:i        {: RESULT = new Node(i); :}
             | FLOAT:i      {: RESULT = new Node(i); :}
             | BOOLEAN:i    {: RESULT = new Node(i); :}
             | IDENTIFIER:i {: RESULT = new Node(i); :}
             
             | CHAR:i       {: RESULT = new Node(i); :}
             | STR:i        {: RESULT = new Node(i); :}
             | COMMENT:t    {: RESULT = new Node(t); :};
             
full_exp ::= simple_exp:e SEMICOL {::};
         
simple_exp ::= types:i {::}
            | simple_exp:e1 operator:o simple_exp:e2 {::}
            | LPAREN simple_exp:e RPAREN {::};

operator ::= PLUS  {: RESULT = new Node("+"); :}
           | MINUS {: RESULT = new Node("-"); :}
           | MULT  {: RESULT = new Node("*"); :}
           | DIV   {: RESULT = new Node("/"); :};
           
sequence ::= SEQD PLPAREN DATATYPE:i PRPAREN IDENTIFIER:t EQUAL SEQ:k {:
              Node n = new Node("=");
              Node m = new Node(t);
              n.addChild(m);
              n.addChild(new Node(k));
              m.addChild(new Node("seq"));
              m.addChild(new Node("<"));
              m.addChild(new Node(i));
              m.addChild(new Node(">"));
              RESULT = (Node)n;
           :}
           | SEQD PLPAREN DATATYPE:i PRPAREN IDENTIFIER:t EQUAL STR:k {:
           :}
           | SEQD PLPAREN IDENTIFIER:t PRPAREN {:
           :};

dictionary ::= DICTD PLPAREN DATATYPE:i COMMA DATATYPE:j PRPAREN IDENTIFIER:t EQUAL DICT:k {:
                Node n = new Node("=");
                Node m = new Node (",");
                n.addChild(m);
                Node gr = new Node ("<");
                Node gl = new Node (">");
                m.addChild(gr);
                m.addChild(gl);
                gr.addChild(new Node("dict"));
                gr.addChild(new Node (i));
                gl.addChild(new Node (j));
                gl.addChild(new Node (t));
                n.addChild(new Node (k));
                RESULT = (Node)n;
              :};
             
dictionary_assignment ::= IDENTIFIER:t SLPAREN IDENTIFIER:i SRPAREN EQUAL IDENTIFIER:j {:
                          Node n = new Node("=");
                          Node m = new Node(t);
                          n.addChild(m);
                          n.addChild(new Node(j));
                          m.addChild(new Node("["));
                          m.addChild(new Node(i));
                          m.addChild(new Node("]"));
                          RESULT = (Node)n;
                       :};

sequence_operations ::= LEN LPAREN IDENTIFIER:t RPAREN {:
                         Node n = new Node(t);
                         n.addChild(new Node("len"));
                         n.addChild(new Node("("));
                         n.addChild(new Node(")"));
                         RESULT = (Node)n;
                      :}
                      | LEN LPAREN IDENTIFIER:t RPAREN operator:e INT:i {:
                         Node n = new Node(e);
                         Node m = new Node(t);
                         n.addChild(m);
                         n.addChild(new Node(i));
                         m.addChild(new Node("len"));
                         m.addChild(new Node("("));
                         m.addChild(new Node(")"));
                      :}
                      | IDENTIFIER:t INDEX:s {:
                      :}
                      | IDENTIFIER:t SLPAREN LEN LPAREN IDENTIFIER:s RPAREN INT:i SRPAREN {:
                        Node n = new Node(t);
                        n.addChild(new Node("["));
                        n.addChild(new Node("len"));
                        n.addChild(new Node("("));
                        n.addChild(new Node(s));
                        n.addChild(new Node(")"));
                        n.addChild(new Node("]"));
                        n.addChild(new Node(i));
                        RESULT = (Node)n;
                      :}
                      | IDENTIFIER:t SLPAREN LEN LPAREN IDENTIFIER:s RPAREN operator:e INT:i SRPAREN {:
                      :}
                      | IDENTIFIER:t SLPAREN IDENTIFIER:s operator:e INT:i SRPAREN {:
                      :}
                      | IDENTIFIER:t SLPAREN INT:i COLON INT:j SRPAREN {:
                      :}
                      | IDENTIFIER:t SLPAREN COLON INT:J SRPAREN {:
                      :}
                      | IDENTIFIER:t SLPAREN INT:i COLON SRPAREN {:
                      :}
                      | IDENTIFIER:t SLPAREN INT:i COLON sequence_operations:e {:
                      :};
                      
                      
colon ::= COLON {: RESULT = new Node(":"); :};

declaration_list ::= IDENTIFIER:i IDENTIFIER:j {::}
                   | IDENTIFIER:i IDENTIFIER:j COMMA declaration_list:e {::}
                   | DATATYPE:i IDENTIFIER:j {::}
                   | DATATYPE:i IDENTIFIER:j COMMA declaration_list:e {::}
                   | sequence:e IDENTIFIER:j {::}
                   | sequence:f IDENTIFIER:g COMMA declaration_list:h {::};
                    
data_type_declaration ::= TDEF IDENTIFIER:i CLPAREN declaration_list:e CRPAREN SEMICOL {::};

method_declarations ::= IDENTIFIER:i DOT IDENTIFIER:j {::}
                      | method_declarations:i operator:e INT:j{::}
                      | method_declarations:i operator:e FLOAT:j{::}
                      | method_declarations:i operator:e RAT:j{::}
                      | INT:j operator:e method_declarations:i {::}
                      | FLOAT:j operator:e method_declarations:i {::}
                      | RAT:j operator:e method_declarations:i {::};
                      
let_bind ::= LET IDENTIFIER:i EQUAL full_exp:e {:
               Node n = new Node("LET");
               n.addChild(new Node(i));
               n.addChild((Node)e);
               RESULT = n;
             :};

test ::= BOOLEAN:i {:
               Node n = new Node(i);
               RESULT = n;
             :};
